#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;
// layout(std140, set = 0, binding = 0) uniform global_t
// {
// } global;
layout(std140, set = 0, binding = 1) uniform params_t
{
  int mode;
  int L0;
  int projection;
  float alpha;
  float dspyl;
  float dspyc;
  float dspyh;
} params;
layout(push_constant, std140) uniform push_t
{
  int have_pick;
} push;
layout(set = 1, binding = 0) uniform sampler2D img_in;
layout(set = 1, binding = 1) uniform writeonly image2D img_dspy;
#define HAVE_NO_ATOMICS
layout( // picked colour if any.
    set = 1, binding = 2
#ifdef HAVE_NO_ATOMICS
) uniform usampler2D img_pick;
#else
) uniform sampler2D img_pick;
#endif


// #include "common.glsl"
#include "common-precomp.glsl"

#define DISPLAY_SATURATION_MODE                0     // set to 1 to display grey scale saturation
#define IS_DISPLAY_GAMUT_CUSP_POINT            1
#define IS_DISPLAY_GAMUT_CLIP_LINE             1
#define IS_DISPLAY_sRGB_COLOR_NEAR_ZERO_LINE   1
#define IS_DISPLAY_sRGB_COLOR_NEAR_ONE_LINE    1
#define IS_DISPLAY_TEXT_HUE                    1
#define IS_DISPLAY_TEXT_MOUSE_RGB              1
#define IS_DISPLAY_OUT_OF_GAMUT_COLOR          0
#define DRAW_SCALE_CL_MIN                      vec2(0.0, -0.0)
#define DRAW_SCALE_CL_MAX                      vec2(0.5,  1.0)

#define iResolution vec3(imageSize(img_dspy),1)
#define RESOLUTION  .35

// some of the function are borrowed from the following shader toy source code
// https://www.shadertoy.com/view/wdXBDS
// https://www.shadertoy.com/view/WlGyDG

float degree_to_radian(float deg)
{
    return deg * (3.14159265359 / 180.0);
}

float radian_to_degree(float rad)
{
    return rad * (180.0 / 3.14159265359);
}

float sdLine(in vec2 p,in vec2 a,in vec2 b)
{
    /// Project p onto the line ab, then return the distance from p` to p
    
	// Use a as 'origin'
    vec2 origin = a;    
    vec2 p2 = p-origin;
    vec2 b2 = b-origin;

    // Compute the dot product of vectors and divide to get the ratio
	float lineRatio = dot(p2, b2)/dot(b2, b2);

    // Clamp the ratio between 0.0 and 1.0
    lineRatio = clamp(lineRatio, 0., 1.);

    // Nearest point on AB
    vec2 pointOnLine = b2*lineRatio;

    // Return distance from line to point
    return 1. - step(0.5, length(p2 - pointOnLine));
}



// based on works of TimoKinnunen
// https://www.shadertoy.com/view/4lGSzV
// draws float <value> at iDrawCoord-<charCoord>
// works fine, but not for big decimals
float drawFloat(in vec2 charCoord, float value,
		float digits, float decimals) {
        
    // round to closest dp
    float dp_multiplier= pow(10., decimals);
    value= round(value * dp_multiplier) / dp_multiplier;
    
	charCoord *= RESOLUTION*RESOLUTION;
	float bits = 0.;
	if(charCoord.y < 0. || charCoord.y >= 1.5 || charCoord.x < step(-value,0.)) return bits;
	float digitIndex = digits - floor(charCoord.x)+ 1.;
	if(- digitIndex <= decimals) {
		float pow1 = pow(10., digitIndex);
		float absValue = abs(value);
		float pivot = max(absValue, 1.5) * 10.;
		if(pivot < pow1) bits = 1792.*float(value < 0. && pivot >= pow1 * .1);
		else if(digitIndex == 0.) bits = 2.*float(decimals > 0.);
		else {
        	value = digitIndex < 0. ? fract(absValue) : absValue * 10.;
            int x=int (mod(value / pow1, 10.));
			bits = x==0?480599.:x==1?139810.:x==2?476951.:x==3?476999.:x==4?350020.:x==5?464711.:x==6?464727.:x==7?476228.:x==8?481111.:x==9?481095.:0.;
		}
	}
	return floor(mod(bits / pow(2., floor(fract(charCoord.x) * 4.) + floor(charCoord.y * 4.) * 4.), 2.));
}

float drawCircle(vec2 pxCoord, vec2 circlePos, float circleRadius)
{
    return float(length(pxCoord - circlePos) <= circleRadius);
}

vec2 pxCoord_to_CL(vec2 pxPos)
{
  vec2 CL_range= DRAW_SCALE_CL_MAX - DRAW_SCALE_CL_MIN;
  return (pxPos / iResolution.xy) * CL_range + DRAW_SCALE_CL_MIN;
}

vec2 CL_to_pxCoord(vec2 CL)
{
    vec2 CL_range= DRAW_SCALE_CL_MAX - DRAW_SCALE_CL_MIN;
    return ((CL - DRAW_SCALE_CL_MIN)/CL_range)* iResolution.xy;
}

float drawCircleAtLC(vec2 pxCoord, LC circlePosLC, float circleRadius)
{
  return drawCircle(pxCoord, CL_to_pxCoord(circlePosLC.yx), circleRadius);
}

float OETF_rec709_f(float val)
{
	return val < 0.018 ? val * 4.5: 1.099 * pow(val, 0.45) - 0.099;
}

vec3 OETF_rec709(vec3 val)
{
	return vec3(OETF_rec709_f(val.r), OETF_rec709_f(val.g), OETF_rec709_f(val.b));
}

void mainImage(out vec4 fragColor, vec2 fragCoord, vec3 LCh_picked)
{
  
  // project out of gamut point back to gamut boundary
  float L1 = LCh_picked.x;
  float C1 = LCh_picked.y;
  float hue = LCh_picked.z;
  float a_ = cos(hue);
  float b_ = sin(hue);
  // OR
  // float a_ = lab.y / C;
	// float b_ = lab.z / C;
  
  // compute rgb_dir for a given color space
  vec3 r_lab = rgb_to_oklab(vec3(1,0,0));
  vec3 g_lab = rgb_to_oklab(vec3(0,1,0));
  vec3 b_lab = rgb_to_oklab(vec3(0,0,1));

  float r_h = atan(r_lab.z, r_lab.y);
  float g_h = atan(g_lab.z, g_lab.y);
  float b_h = atan(b_lab.z, b_lab.y);

  vec2 r_dir = 0.5*vec2(cos(b_h)+cos(g_h), sin(b_h)+sin(g_h));
  vec2 g_dir = 0.5*vec2(cos(b_h)+cos(r_h), sin(b_h)+sin(r_h));
  vec2 b_dir = 0.5*vec2(cos(r_h)+cos(g_h), sin(r_h)+sin(g_h));
  
  r_dir /= dot(r_dir, r_dir);
  g_dir /= dot(g_dir, g_dir);
  b_dir /= dot(b_dir, b_dir);
  
  // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
  LC cusp = find_cusp(a_, b_);
  // LC cusp = find_cusp(a_, b_, r_dir, g_dir, b_dir);

  float L_clipped;
  float C_clipped;
  float L0;
  if (params.mode == 0) {
    L0 = clamp(L1, 0, 1);

    float t = find_gamut_intersection(a_, b_, L1, C1, L0);
    // float t = find_gamut_intersection(a_, b_, L1, C1, L0, r_dir, g_dir, b_dir);
    L_clipped = L0 * (1 - t) + t * L1;
    C_clipped = t * C1;
  }
  else 
  {
    if (params.projection == 0) { // single point
      if (params.L0 == 0) {          // L0 = 0.5
        L0 = 0.5;

        float t = find_gamut_intersection(a_, b_, L1, C1, L0);
        // float t = find_gamut_intersection(a_, b_, L1, C1, L0, r_dir, g_dir, b_dir);
        L_clipped = L0 * (1 - t) + t * L1;
        C_clipped = t * C1;
      } else {                         // L0 = L_cusp
        L0 = cusp.x;

        float t = find_gamut_intersection(a_, b_, L1, C1, L0);
        // float t = find_gamut_intersection(a_, b_, L1, C1, L0, r_dir, g_dir, b_dir);
        L_clipped = L0 * (1 - t) + t * L1;
        C_clipped = t * C1;
      }
    } else {                      // adaptive
      if (params.L0 == 0) {          // L0 = 0.5
        float Ld = L1 - 0.5f;
        float e1 = 0.5f + abs(Ld) + params.alpha * C1;
        L0 = 0.5f*(1.f + sign(Ld)*(e1 - sqrt(e1*e1 - 2.f *abs(Ld))));

        float t = find_gamut_intersection(a_, b_, L1, C1, L0);
        // float t = find_gamut_intersection(a_, b_, L1, C1, L0, r_dir, g_dir, b_dir);
        L_clipped = L0 * (1.f - t) + t * L1;
        C_clipped = t * C1;
      } else {                         // L0 = L_cusp  
        float Ld = L1 - cusp.x;
        float k = 2.f * (Ld > 0 ? 1.f - cusp.x : cusp.x);

        float e1 = 0.5f*k + abs(Ld) + params.alpha * C1/k;
        L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));

        float t = find_gamut_intersection(a_, b_, L1, C1, L0);
        // float t = find_gamut_intersection(a_, b_, L1, C1, L0, r_dir, g_dir, b_dir);
        L_clipped = L0 * (1.f - t) + t * L1;
        C_clipped = t * C1;
      }
    }
  }

  LC LC_0      = LC(L0, 0);
  LC LC_1      = LCh_picked.xy;
  LC LC_clipped = LC(L_clipped, C_clipped);
    
  // convert pixel position to lightness and chroma
  vec2  CL_px    = pxCoord_to_CL(fragCoord);
  float sat_px   = CL_px.x / CL_px.y;
  vec3  oklab_px = oklab_LCh_to_Lab(CL_px.y, CL_px.x, hue);
  // convert pixel color to sRGB space
  vec3 rgb_px    = oklab_to_rgb(oklab_px);
  vec3 clipped_rgb_px= clamp(rgb_px, 0., 1.);
  
  // compute output color
  float epsilon0 = 0.0025 * pow(clamp(CL_px.y, 0., 1.), 1.5);  // scale down epsilon when close to zero
  bool  isAnyChannelCloseToZeroR = abs(rgb_px.r) < epsilon0;
  bool  isAnyChannelCloseToZeroG = abs(rgb_px.g) < epsilon0;
  bool  isAnyChannelCloseToZeroB = abs(rgb_px.b) < epsilon0;

  float epsilon1 = 0.005;
  bool  isAnyChannelCloseToOneR = abs(rgb_px.r - 1.) < epsilon1;
  bool  isAnyChannelCloseToOneG = abs(rgb_px.g - 1.) < epsilon1;
  bool  isAnyChannelCloseToOneB = abs(rgb_px.b - 1.) < epsilon1;

  bool  isOutOfGamut = rgb_px.r != clipped_rgb_px.r ||
                       rgb_px.g != clipped_rgb_px.g ||
                       rgb_px.b != clipped_rgb_px.b ;

#if IS_DISPLAY_sRGB_COLOR_NEAR_ZERO_LINE
  if (isAnyChannelCloseToZeroR)
      fragColor = vec4(.4,0.,0.,1.);
  else if (isAnyChannelCloseToZeroG)
      fragColor = vec4(0.,.35,0.,1.);
  else if (isAnyChannelCloseToZeroB)
      fragColor = vec4(0.,0.,.45,1.);
  else
#endif
#if IS_DISPLAY_sRGB_COLOR_NEAR_ONE_LINE
  if (isAnyChannelCloseToOneR)
      fragColor = vec4(1.,0.,0.,1.);
  else if (isAnyChannelCloseToOneG)
      fragColor = vec4(0.,1.,0.,1.);
  else if (isAnyChannelCloseToOneB)
      fragColor = vec4(0.,0.,1.,1.);
  else
#endif
#if !IS_DISPLAY_OUT_OF_GAMUT_COLOR
  if(isOutOfGamut)  // out of gamut
      fragColor = vec4(.1, .1, .1, 1.); // same as ciediag
  else
#endif
  {
    // within gamut
#if DISPLAY_SATURATION_MODE
    fragColor = vec4(sat_px, sat_px, sat_px, 1.);
#else
    fragColor = vec4(OETF_rec709(clipped_rgb_px), 1.);
#endif
  }

  // draw current HUE in upper right corner
#if IS_DISPLAY_TEXT_HUE
  fragColor += drawFloat(fragCoord-vec2(iResolution.x - 80., iResolution.y - 20.), radian_to_degree(hue), 3.0,2.0);
#endif
  // draw RGB
#if IS_DISPLAY_TEXT_MOUSE_RGB
  // fragColor += drawFloat(fragCoord-vec2(000.0, 10.0), rgb_picked.r, 1.0,4.0);
  // fragColor += drawFloat(fragCoord-vec2(100.0, 10.0), rgb_picked.g, 1.0,4.0);
  // fragColor += drawFloat(fragCoord-vec2(200.0, 10.0), rgb_picked.b, 1.0,4.0);
#endif
  
  // draw gamut cusp
#if IS_DISPLAY_GAMUT_CUSP_POINT
  fragColor += drawCircleAtLC(fragCoord, cusp, 3.0);
#endif

  // draw mouse position, gamut project to position and gamut clipped position
#if IS_DISPLAY_GAMUT_CLIP_LINE
  fragColor += drawCircleAtLC(fragCoord, LC_1, 3.0);
  fragColor += drawCircleAtLC(fragCoord, LC_0  , 3.0);
  fragColor += drawCircleAtLC(fragCoord, LC_clipped   , 3.0);
  
  // draw project line
  fragColor += sdLine(fragCoord, CL_to_pxCoord(LC_clipped.yx), CL_to_pxCoord(LC_0.yx))*0.2;
  fragColor += sdLine(fragCoord, CL_to_pxCoord(LC_1.yx), CL_to_pxCoord(LC_0.yx));
#endif

}


void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_dspy)))) return;

  // these adapt for shadertoy coord system (y flipped)
  vec2 flippedCoords = vec2(ipos.x, imageSize(img_dspy).y - ipos.y - 1);
  vec3 LCh_picked = vec3(params.dspyl, params.dspyc, degree_to_radian(params.dspyh));
  // vec3 picked_rgb;
  if (push.have_pick > 0) {
    const int i = 0; // which one of the colour pickers
    vec3 picked_rgb = vec3(
    #ifdef HAVE_NO_ATOMICS
            uintBitsToFloat(texelFetch(img_pick, ivec2(i, 0), 0).r),
            uintBitsToFloat(texelFetch(img_pick, ivec2(i, 1), 0).r),
            uintBitsToFloat(texelFetch(img_pick, ivec2(i, 2), 0).r));
    #else
            texelFetch(img_pick, ivec2(i, 0), 0).r,
            texelFetch(img_pick, ivec2(i, 1), 0).r,
            texelFetch(img_pick, ivec2(i, 2), 0).r);
    #endif
    vec3 lab = rec2020_to_oklab(picked_rgb);
    LCh_picked = oklab_Lab_to_LCh(lab.x, lab.y, lab.z);
  }

  vec4 rgb_dspy;
  mainImage(rgb_dspy, vec2(flippedCoords) + vec2(0.5), LCh_picked);
  imageStore(img_dspy, ipos, rgb_dspy);
}
